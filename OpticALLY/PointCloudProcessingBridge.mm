#import "PointCloudProcessingBridge.h"
#include <open3d/Open3D.h>
#include <vector>
#include <memory>
#include <fstream>
#include <Eigen/Dense>
#include <filesystem>
#include <regex>
#include <future>
#include "ImageDepth.hpp"

@implementation PointCloudProcessingBridge

+ (BOOL)processPointCloudsWithCalibrationFile:(NSString *)calibrationFilePath
                                   imageFiles:(NSArray<NSString *> *)imageFiles
                                   depthFiles:(NSArray<NSString *> *)depthFiles
                                  outputPaths:(NSArray<NSString *> *)outputPaths {
    using namespace open3d;
    using namespace geometry;
    namespace fs = std::filesystem;

    // Helper function to extract numeric part from filename
    auto extractNumber = [](const std::string &filename) -> int {
        std::regex re("\\d+");
        std::smatch match;
        if (std::regex_search(filename, match, re)) {
            return std::stoi(match.str());
        }
        return -1;
    };

    // Convert NSArray to std::vector
    std::vector<std::pair<int, std::string>> numberedImageFiles;
    std::vector<std::pair<int, std::string>> numberedDepthFiles;
    std::vector<std::string> cppOutputPaths;

    for (NSString *path in imageFiles) {
        std::string stdPath = [path UTF8String];
        int number = extractNumber(stdPath);
        numberedImageFiles.emplace_back(number, stdPath);
    }

    for (NSString *path in depthFiles) {
        std::string stdPath = [path UTF8String];
        int number = extractNumber(stdPath);
        numberedDepthFiles.emplace_back(number, stdPath);
    }

    for (NSString *path in outputPaths) {
        std::string stdPath = [path UTF8String];
        cppOutputPaths.push_back(stdPath);
    }

    // Sort based on the extracted number
    std::sort(numberedImageFiles.begin(), numberedImageFiles.end());
    std::sort(numberedDepthFiles.begin(), numberedDepthFiles.end());

    // Extract sorted paths
    std::vector<std::string> cppImageFiles;
    std::vector<std::string> cppDepthFiles;

    for (const auto &pair : numberedImageFiles) {
        cppImageFiles.push_back(pair.second);
    }

    for (const auto &pair : numberedDepthFiles) {
        cppDepthFiles.push_back(pair.second);
    }

    if (cppImageFiles.empty() || cppDepthFiles.empty() || cppOutputPaths.empty()) {
        NSLog(@"No image, depth files or output paths found");
        return NO;
    }

    if (cppImageFiles.size() != cppDepthFiles.size() || cppImageFiles.size() != cppOutputPaths.size()) {
        NSLog(@"Mismatch between the number of image files, depth files, and output paths");
        return NO;
    }

    std::vector<std::shared_ptr<PointCloud>> pointClouds;

    // Print out the lengths of the arrays
    NSLog(@"Number of image files: %lu", (unsigned long)imageFiles.count);
    NSLog(@"Number of depth files: %lu", (unsigned long)depthFiles.count);
    NSLog(@"Number of output paths: %lu", (unsigned long)outputPaths.count);

    std::vector<std::future<std::shared_ptr<PointCloud>>> futures;

    // Process each point cloud in parallel
    for (size_t i = 0; i < cppImageFiles.size(); ++i) {
        futures.push_back(std::async(std::launch::async, [&calibrationFilePath, &cppImageFiles, &cppDepthFiles, i]() -> std::shared_ptr<PointCloud> {
            auto imageDepth = std::make_shared<ImageDepth>([calibrationFilePath UTF8String], cppImageFiles[i], cppDepthFiles[i], 640, 480, 0.1, 0.5, 0.01);
            auto pointCloud = imageDepth->getPointCloud();
            if (!pointCloud || pointCloud->points_.empty()) {
                return nullptr;
            }
            return pointCloud;
        }));
    }

    // Collect all point clouds
    for (auto &f : futures) {
        auto pointCloud = f.get();
        if (pointCloud && !pointCloud->IsEmpty()) {
            pointClouds.push_back(pointCloud);
        }
    }

    if (pointClouds.empty()) {
        NSLog(@"No valid point clouds generated");
        return NO;
    }

    size_t depth = 9; // or another appropriate value based on your needs
    float scale = 1.1f;
    bool linear_fit = false; // Set to true if you need linear interpolation

    for (size_t i = 0; i < pointClouds.size(); ++i) {
        auto pointCloud = pointClouds[i];

        // Call the Poisson reconstruction with a single thread
        auto [mesh, densities] = open3d::geometry::TriangleMesh::CreateFromPointCloudPoisson(
            *pointCloud,
            depth,
            0,      // Width is ignored if depth is set
            scale,
            linear_fit,
            1       // Setting n_threads to 1 (VERY IMPORTANT)
        ); // VVIP: FORCE THREAD COUNT TO 1 TO PREVENT "FAILED CLOSING THE LOOP" ERROR!

        const double threshold = 0.004893;
        std::cout << "Remove artifacts and large triangles generated by screened Poisson" << std::endl;

        std::vector<bool> trianglesToRemove(mesh->triangles_.size(), false);
        for (size_t j = 0; j < mesh->triangles_.size(); ++j) {
            auto& tri = mesh->triangles_[j];
            double edgeLengths[3] = {
                (mesh->vertices_[tri[0]] - mesh->vertices_[tri[1]]).norm(),
                (mesh->vertices_[tri[1]] - mesh->vertices_[tri[2]]).norm(),
                (mesh->vertices_[tri[2]] - mesh->vertices_[tri[0]]).norm()
            };
            if (edgeLengths[0] > threshold || edgeLengths[1] > threshold || edgeLengths[2] > threshold) {
                trianglesToRemove[j] = true;
            }
        }

        mesh->RemoveTrianglesByMask(trianglesToRemove);
        mesh->RemoveUnreferencedVertices();
        mesh->RemoveNonManifoldEdges();

        std::cout << "Now exporting OBJ..." << std::endl;

        fs::path outputFilePath = cppOutputPaths[i];
        if (!fs::exists(outputFilePath.parent_path())) {
            std::cerr << "Output directory does not exist: " << outputFilePath.parent_path() << std::endl;
            return NO;
        }

        std::cout << "Mesh has " << mesh->vertices_.size() << " vertices and " << mesh->triangles_.size() << " triangles." << std::endl;
        if (mesh->vertices_.empty() || mesh->triangles_.empty()) {
            NSLog(@"Mesh is empty, cannot write to file.");
            return NO;
        }

        try {
            if (!io::WriteTriangleMesh(outputFilePath.string(), *mesh, false)) {
                NSLog(@"Failed to write OBJ file");
                return NO;
            }
        } catch (const std::exception &e) {
            std::cerr << "Exception occurred while writing OBJ file: " << e.what() << std::endl;
            return NO;
        }
    }

    NSLog(@"Successfully exported OBJ files.");

    return YES;
}

@end
