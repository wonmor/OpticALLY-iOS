// PointCloudProcessingBridge.mm

#import "PointCloudProcessingBridge.h"
#include <open3d/Open3D.h>
#include <vector>
#include <memory>
#include <fstream>
#include <Eigen/Dense>
#include <filesystem>
#include "ImageDepth.hpp"

@implementation PointCloudProcessingBridge

+ (BOOL)processPointCloudsWithCalibrationFile:(NSString *)calibrationFilePath
                                   imageFiles:(NSArray<NSString *> *)imageFiles
                                   depthFiles:(NSArray<NSString *> *)depthFiles
                                   outputPath:(NSString *)outputPath {
    using namespace open3d;
    using namespace geometry;
    namespace fs = std::filesystem;

    // Convert NSArray to std::vector
    std::vector<std::string> cppImageFiles;
    for (NSString *path in imageFiles) {
        cppImageFiles.push_back([path UTF8String]);
    }

    std::vector<std::string> cppDepthFiles;
    for (NSString *path in depthFiles) {
        cppDepthFiles.push_back([path UTF8String]);
    }

    if (cppImageFiles.empty() || cppDepthFiles.empty()) {
        NSLog(@"No image or depth files found");
        return NO;
    }

    std::vector<std::shared_ptr<PointCloud>> pointClouds;
    
    // Print out the lengths of both arrays
    NSLog(@"Number of image files: %lu", (unsigned long)imageFiles.count);
    NSLog(@"Number of depth files: %lu", (unsigned long)depthFiles.count);
    
    if (imageFiles.count != depthFiles.count) {
        NSLog(@"Mismatch between the number of image files and depth files");
        return NO;
    }
    if (imageFiles.count == 0) {
        NSLog(@"No image files available");
        return NO;
    }
    if (depthFiles.count == 0) {
        NSLog(@"No depth files available");
        return NO;
    }

    for (size_t i = 0; i < cppImageFiles.size(); ++i) {
        auto imageDepth = std::make_shared<ImageDepth>([calibrationFilePath UTF8String], cppImageFiles[i], cppDepthFiles[i], 640, 480, 0.1, 0.5, 0.01);
        auto pointCloud = imageDepth->getPointCloud();

        if (!pointCloud) {
            std::cerr << "Error: Failed to generate point cloud for image file: " << imageFiles[i] << " and depth file: " << depthFiles[i] << std::endl;
            continue; // Skip this point cloud
        }

        if (pointCloud->points_.empty()) {
            std::cerr << "Warning: Point cloud generated but contains no points for image file: " << imageFiles[i] << " and depth file: " << depthFiles[i] << std::endl;
            continue; // Skip empty point clouds
        }

        pointClouds.push_back(pointCloud);
    }

    auto globalPCD = pointClouds[0]; // Assuming only the first point cloud is processed
    std::cout << "Meshing ..." << std::endl;
    
    // Ensure globalPCD is not null
    if (!globalPCD) {
        NSLog(@"globalPCD is null");
        return NO;
    }

    // Ensure the point cloud has points
    if (globalPCD->points_.empty()) {
        NSLog(@"No points in globalPCD");
        return NO;
    }
    
    if (globalPCD->IsEmpty()) {
        NSLog(@"Point cloud is empty, skipping mesh generation.");
        return NO;
    }
    
    size_t depth = 9; // or another appropriate value based on your needs
    float scale = 1.1f;
    bool linear_fit = false; // Set to true if you need linear interpolation

    // Call the Poisson reconstruction with a single thread
    auto [mesh, densities] = open3d::geometry::TriangleMesh::CreateFromPointCloudPoisson(
        *globalPCD,
        depth,
        0,      // Width is ignored if depth is set
        scale,
        linear_fit,
        1       // Setting n_threads to 1
    ); // VVIP: FORCE THREAD COUNT TO 1 TO PREVENT "FAILED CLOSING THE LOOP" ERROR!

//        const double threshold = 0.004893;
//        std::cout << "Remove artifacts and large triangles generated by screened Poisson" << std::endl;
//
//        std::vector<bool> trianglesToRemove(mesh->triangles_.size(), false);
//        for (size_t i = 0; i < mesh->triangles_.size(); ++i) {
//            auto& tri = mesh->triangles_[i];
//            double edgeLengths[3] = {
//                (mesh->vertices_[tri[0]] - mesh->vertices_[tri[1]]).norm(),
//                (mesh->vertices_[tri[1]] - mesh->vertices_[tri[2]]).norm(),
//                (mesh->vertices_[tri[2]] - mesh->vertices_[tri[0]]).norm()
//            };
//            if (edgeLengths[0] > threshold || edgeLengths[1] > threshold || edgeLengths[2] > threshold) {
//                trianglesToRemove[i] = true;
//            }
//        }
//
//        mesh->RemoveTrianglesByMask(trianglesToRemove);
//        mesh->RemoveUnreferencedVertices();
//        mesh->RemoveNonManifoldEdges();
    
    std::cout << "Now exporting OBJ..." << std::endl;

    fs::path outputFilePath = fs::path([outputPath UTF8String]) / "output.obj";
    if (!fs::exists(outputFilePath.parent_path())) {
        std::cerr << "Output directory does not exist: " << outputFilePath.parent_path() << std::endl;
        return NO;
    }
    
    std::cout << "Mesh has " << mesh->vertices_.size() << " vertices and " << mesh->triangles_.size() << " triangles." << std::endl;
    if (mesh->vertices_.empty() || mesh->triangles_.empty()) {
        NSLog(@"Mesh is empty, cannot write to file.");
        return NO;
    }
    
    try {
        if (!io::WriteTriangleMesh(outputFilePath.string(), *mesh, false)) {
            NSLog(@"Failed to write OBJ file at %@", [outputPath UTF8String]);
            return NO;
        }
    } catch (const std::exception &e) {
        std::cerr << "Exception occurred while writing OBJ file: " << e.what() << std::endl;
        return NO;
    }

    
    NSLog(@"Successfully exported OBJ file.");

    return YES;
}

@end
