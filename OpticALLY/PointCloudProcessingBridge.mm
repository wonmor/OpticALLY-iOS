// PointCloudProcessingBridge.mm

#import "PointCloudProcessingBridge.h"
#include <open3d/Open3D.h>
#include <vector>
#include <memory>
#include <fstream>
#include <Eigen/Dense>
#include <filesystem>
#include "ImageDepth.hpp"

@implementation PointCloudProcessingBridge

+ (BOOL)processPointCloudsWithCalibrationFile:(NSString *)calibrationFilePath
                                   imageFiles:(NSArray<NSString *> *)imageFiles
                                   depthFiles:(NSArray<NSString *> *)depthFiles
                                   outputPath:(NSString *)outputPath {
    using namespace open3d;
    using namespace geometry;
    namespace fs = std::filesystem;

    // Convert NSArray to std::vector
    std::vector<std::string> cppImageFiles;
    for (NSString *path in imageFiles) {
        cppImageFiles.push_back([path UTF8String]);
    }

    std::vector<std::string> cppDepthFiles;
    for (NSString *path in depthFiles) {
        cppDepthFiles.push_back([path UTF8String]);
    }

    if (cppImageFiles.empty() || cppDepthFiles.empty()) {
        NSLog(@"No image or depth files found");
        return NO;
    }

    std::vector<std::shared_ptr<PointCloud>> pointClouds;
    for (size_t i = 0; i < cppImageFiles.size(); ++i) {
        auto imageDepth = std::make_shared<ImageDepth>([calibrationFilePath UTF8String], cppImageFiles[i], cppDepthFiles[i], 640, 480, 0.1, 0.5, 0.01);
        auto pointCloud = imageDepth->getPointCloud();

        if (!pointCloud) {
            std::cerr << "Error: Failed to generate point cloud for image file: " << imageFiles[i] << " and depth file: " << depthFiles[i] << std::endl;
            continue; // Skip this point cloud
        }

        if (pointCloud->points_.empty()) {
            std::cerr << "Warning: Point cloud generated but contains no points for image file: " << imageFiles[i] << " and depth file: " << depthFiles[i] << std::endl;
            continue; // Skip empty point clouds
        }

        pointClouds.push_back(pointCloud);
    }

    auto globalPCD = pointClouds[0]; // Assuming only the first point cloud is processed
    std::cout << "Meshing ..." << std::endl;
    
    // Ensure globalPCD is not null
    if (!globalPCD) {
        NSLog(@"globalPCD is null");
        return NO;
    }

    // Ensure the point cloud has points
    if (globalPCD->points_.empty()) {
        NSLog(@"No points in globalPCD");
        return NO;
    }
    
    auto [mesh, densities] = TriangleMesh::CreateFromPointCloudPoisson(*globalPCD, 9);

    const double threshold = 0.004893;
    std::cout << "Remove artifacts and large triangles generated by screened Poisson" << std::endl;

    std::vector<bool> trianglesToRemove(mesh->triangles_.size(), false);
    for (size_t i = 0; i < mesh->triangles_.size(); ++i) {
        auto& tri = mesh->triangles_[i];
        double edgeLengths[3] = {
            (mesh->vertices_[tri[0]] - mesh->vertices_[tri[1]]).norm(),
            (mesh->vertices_[tri[1]] - mesh->vertices_[tri[2]]).norm(),
            (mesh->vertices_[tri[2]] - mesh->vertices_[tri[0]]).norm()
        };
        if (edgeLengths[0] > threshold || edgeLengths[1] > threshold || edgeLengths[2] > threshold) {
            trianglesToRemove[i] = true;
        }
    }

    mesh->RemoveTrianglesByMask(trianglesToRemove);
    mesh->RemoveUnreferencedVertices();
    mesh->RemoveNonManifoldEdges();

    fs::path outputFilePath = fs::path([outputPath UTF8String]) / "output.obj";
    io::WriteTriangleMesh(outputFilePath.string(), *mesh);

    return YES;
}

@end
